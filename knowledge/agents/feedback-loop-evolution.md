---
title: "Closed Feedback Loop — автономная эволюция агентов через замкнутый цикл обратной связи"
source: "https://youtu.be/gTKB9dDicNA"
source_type: video
status: processed
added: 2026-02-11
updated: 2026-02-11
review_by: 2026-05-11
tags: [agents, evolution, feedback-loop, evals, pattern]
publish: false
version: 1
---

# Closed Feedback Loop — эволюция агентов

## Кратко

Архитектурный паттерн, в котором AI-агент автономно улучшает своё поведение через замкнутый цикл: выполнить задачу → прогнать eval → проанализировать ошибки → эволюировать промпт или код → повторить. Без участия человека. В конце 2025 — начале 2026 несколько независимых команд применили этот подход и получили результаты, недостижимые вручную. Ключевое условие — наличие измеримых evals (score, pass/fail). Стало возможным на моделях уровня Claude Opus 4+ и GPT-5.2, которые перешагнули порог качества кода.

## Паттерн

```
Run Agent → Eval (score) → Analyzer → Evolver → Run Agent (next generation)
                ↑                                        |
                └────────────────────────────────────────┘
```

**Три обязательных компонента:**

1. **Agent** — выполняет целевую задачу (отвечает на вопросы, пишет код, переводит)
2. **Eval** — измеримая обратная связь. Число: score, pass/fail, количество пройденных тестов. Субъективная оценка ("похоже на хороший дизайн") не работает
3. **Evolver** — анализирует результаты + историю предыдущих попыток → генерирует следующее поколение (промпта, кода, параметров)

**Что может эволюировать:**
- Системный промпт (правила, few-shot примеры, структура)
- Код агента (инструменты, логика)
- Параметры (выбор модели, температура)

**Что важно для Evolver:**
- Видит историю предыдущих поколений и их ошибок (не повторяет одно и то же)
- Планирует следующий шаг осознанно
- Умеет компактизировать (дедупликация правил, рефакторинг)

## Условия применимости

| Условие | Почему |
|---------|--------|
| Evals в цифре | Без измеримой обратной связи цикл не замкнуть |
| Модели уровня Opus 4+ / GPT-5.2 | На слабых моделях код деградирует в спагетти за N поколений |
| Достаточный бюджет на токены | Десятки поколений × полные прогоны = дорого |
| Задача допускает автоматическое тестирование | Если eval требует человека — цикл разрывается |

**Где НЕ работает:** генерация свободного текста (a-la Perplexity), дизайн, задачи без формализуемой метрики.

## Кейсы (конец 2025 — начало 2026)

**Остриков — ERC3, золото.** ReAct-агент для корпоративной среды. Два субагента (Analyzer + Evolver) автономно эволюировали системный промпт. ~80 поколений → стабильные 100% на бенчмарках. Claude Code + Opus 4. Финальный промпт: 5700 токенов, 34 правила, 21 few-shot.
- Видео: https://youtu.be/gTKB9dDicNA
- Платформа ERC3: https://erc.timetoact-group.at/

**Cursor — FastRender.** Сотни параллельных агентов писали браузер с нуля на Rust за неделю. Архитектура: Planner → Worker → Judge. 3M+ строк кода. GPT-5.2.
- Блог: https://www.cursor.com/blog/scaling-long-running-autonomous-coding

**Айгиз — перевод YouTube.** Chrome-плагин real-time перевод RU→башкирский. Codex в замкнутом цикле перебирал модели, параметры, код. 9 часов автономной работы. Упоминается в видео Острикова.

**Ринат Абдулин — движок формул.** Excel-like formula engine. Codex + набор тестов. Агенты писали и эволюировали код, дошли до 100%. Код остался архитектурно адекватным. Упоминается в видео Острикова.

## Применимость для нас

- **Skills как eval-driven development:** если скилл имеет тесты/бенчмарки — можно эволюировать автоматически
- **Промпт-эволюция:** для агентов с измеримым качеством (accuracy на задачах клиентов) — замкнуть цикл Analyzer → Evolver
- **Паттерн Analyzer + Evolver** переиспользуем: два субагента, один анализирует логи, второй генерирует следующую версию

## Связанные файлы

- [!agents.md](!agents.md) — сводка по агентным системам, паттерн описан в секции "Архитектурные паттерны"
- [../coding/!coding.md](../coding/!coding.md) — multi-agent кодинг, Agent Teams
