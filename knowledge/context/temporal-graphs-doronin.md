---
title: "Graphiti на практике — опыт Константина Доронина (серия из 11 постов)"
source: "https://t.me/kdoronin_blog/1019"
source_type: thread
status: processed
added: 2026-02-11
updated: 2026-02-11
review_by: 2026-05-11
tags: [graphiti, temporal-graphs, practice, mcp, neo4j, pydantic]
publish: false
version: 1
---

# Graphiti на практике — опыт Константина Доронина

## Кратко

Практический опыт использования Graphiti (temporal knowledge graph) от Константина Доронина (@kdoronin_blog). Серия из 11 постов: от первого запуска до оптимизации production-нагрузок. Реальные метрики: 10-15 сек на эпизод, ~$0.5 за 55 сообщений, 485 эпизодов за 8 минут при параллельной загрузке. Ключевые инсайты: MCP-сервер создаёт только episodes (entity создаёт LLM), Pydantic custom entities делают поведение предсказуемым, наибольший эффект от комбинации структурированных + неструктурированных данных.

Теоретическая база по Graphiti и сравнение фреймворков: [temporal-graphs.md](temporal-graphs.md)

---

## Об авторе

**Константин Доронин** — практик, ведёт канал [@kdoronin_blog](https://t.me/kdoronin_blog). Регулярно публикует кейсы с AI-инструментами, серия про Graphiti — одна из основных.

---

## Карта постов

| # | Пост | Тема |
|---|------|------|
| 1 | [867](https://t.me/kdoronin_blog/867) | Вводный пост про Graphiti |
| 2 | [875](https://t.me/kdoronin_blog/875) | MCP-сервер Graphiti, Neo4j, архитектура |
| 3 | [886](https://t.me/kdoronin_blog/886) | Эксперимент: бот для записи комментариев канала |
| 4 | [890](https://t.me/kdoronin_blog/890) | Результаты эксперимента, метрики |
| 5 | [892](https://t.me/kdoronin_blog/892) | Анализ графа через Goose + MCP |
| 6 | [918](https://t.me/kdoronin_blog/918) | Pydantic для custom entity/relationship |
| 7 | [946](https://t.me/kdoronin_blog/946) | Память программного проекта через MCP + Cursor |
| 8 | [984](https://t.me/kdoronin_blog/984) | Скорость добавления эпизодов |
| 9 | [992](https://t.me/kdoronin_blog/992) | Кейс: анализ отзывов WildBerries |
| 10 | [1012](https://t.me/kdoronin_blog/1012) | Когда Graphiti даёт наибольший эффект |
| 11 | [1016](https://t.me/kdoronin_blog/1016) | Ускорение загрузки эпизодов |

Сборник: [пост 1019](https://t.me/kdoronin_blog/1019) — "темпоральные графы дают преимущество над простым GraphRAG"

---

## Архитектура и внутреннее устройство

**Как Graphiti работает с данными (пост 875):**

- Два типа nodes: **entity** (сущности) и **episodes** (события/действия)
- **MCP-сервер создаёт только episodes.** Entity создаёт сам Graphiti через LLM (OpenAI API)
- Graphiti самостоятельно решает какие entity выделить и какие связи создать
- Внутри entity есть embedding-поле для поиска по графу (через OpenAI embeddings)
- Новые сущности создаются асинхронно и с задержкой — учитывать в production

**Критично:** Для жизнеспособного графа нужна строгая структура передаваемых сообщений. Если формат "гуляет", Graphiti не сможет однозначно привязать эпизод к сущности.

**MCP-нюанс (пост 892):** MCP-сервер требует `group_id` для работы. Нельзя получить все группы по умолчанию — нужно знать ID заранее.

---

## Pydantic для управления сущностями (пост 918)

По умолчанию Graphiti автоматически определяет entity и связи. Pydantic позволяет задать domain-specific контекст:

1. Определить custom entity types (ноды графа)
2. Определить custom relationship types
3. Указать какие ноды могут соединяться какими связями
4. Entities и relationships поддерживают custom fields, заполняемые из эпизодов

**Результат:** Взаимодействие с Graphiti становится предсказуемым и управляемым. Можно добавить промежуточный LLM-слой для фильтрации — определять, подходит ли входящее сообщение под "типичные" паттерны системы.

Доронин создал демо-программу: компании, сотрудники, клиенты — с визуализацией графа.

---

## Метрики производительности

**Скорость (пост 984):**
- На 1 эпизод: несколько запросов в AI API (эмбеддинги, выделение сущностей, описание)
- Среднее время: **10-15 секунд** на эпизод
- Сложные эпизоды (больше сущностей) → дольше
- При 481 ноде и 1300+ связей система работала на ~60% загрузки

**Стоимость (пост 890):**
- 55 сообщений → 112 entity, 160 MENTIONS-связей, 89 RELATES_TO-связей
- Стоимость API: **~$0.5**
- Дефолтные модели: `text-embedding-3-small`, `gpt-4o-mini`
- Слабые модели дают билингвальные описания (ru/en мешаются) — использовать мощнее

**Масштабный кейс (пост 992):**
- Отзывы с WildBerries → **758 нод, 2126 связей**
- Создано 8 аналитических отчётов через Cursor + MCP

---

## Оптимизация загрузки (пост 1016)

Два метода ускорения:

**1. Bulk-операции:**
- Подходят для первичной загрузки
- **Важно:** bulk НЕ перестраивает связи между узлами при создании эпизодов

**2. Параллельная обработка:**
```
USE_PARALLEL_RUNTIME=true
SEMAPHORE_LIMIT=10  # (до 30)
```
- При `SEMAPHORE_LIMIT=30`: **485 эпизодов за 8 минут**
- **Важно:** параллельные эпизоды НЕ связываются между собой. Нужно планировать порядок загрузки — связанные данные отправлять последовательно

---

## Кейсы применения

### Анализ Telegram-комментариев (посты 886, 890, 892)

Telegram-бот записывал комментарии канала в Graphiti → анализ через Goose + MCP-сервер. Три отчёта через Claude Sonnet:
1. Summary обсуждений + участники
2. Deep-dive по связям между сущностями
3. Гипотетические рекомендации по hiring

Claude определил паттерны и даже выявил спамеров, которых система автоматически собрала.

### Анализ отзывов WildBerries (пост 992)

Парсинг отзывов → JSON → Graphiti. Три итерации загрузки:
1. Предзаполненные сущности (ручная работа)
2. Наивная модель (не работает)
3. Финальная: весь текст отзыва как эпизод, система сама создаёт сущности

Результат: 758 нод, 2126 связей. 8 аналитических отчётов: анализ клиентского опыта, качество продукта, сервис, временные тренды, сетевые взаимоотношения, стратегические инсайты, roadmap развития.

### Память программного проекта (пост 946)

Кейс от авторов Graphiti (Zep): граф как память о проекте, интегрированный с Cursor через MCP. Отслеживание изменений, запросы типа "Кто, зачем и когда добавил этот метод?"

Настройка: установить Graphiti → запустить MCP-сервер → добавить Cursor Rules от Zep.

---

## Главный инсайт: когда Graphiti даёт наибольший эффект (пост 1012)

**Комбинация: структурированные + неструктурированные данные (события).**

Пример: отслеживание изменений в топ-менеджменте компаний (структурированные данные) + новости и информация о вакансиях (неструктурированные события). Graphiti выявляет закономерности влияния кадровых решений на информационную политику.

Только структурированные → обычная БД справится. Только неструктурированные → vector store достаточно. Сила Graphiti — на стыке.

---

## Связанные файлы

- [temporal-graphs.md](temporal-graphs.md) — теоретическая база, сравнение фреймворков (Graphiti vs Hindsight vs мёртвые)
- [!context.md](!context.md) — сводка по Context Engineering, RAG, Memory
